#include "dxgiswapchain.h"
#include "dx11/d3d11device.h"
#include "util.h"

DXGISwapChainHook::~DXGISwapChainHook() {
	if (s_)
		s_->Release();
}

template<typename S, int V> HRESULT upgrade(DXGISwapChain * s, REFIID riid, void **ppvObj) {
	if (riid == __uuidof(S) && s->version_ < V) {
		S *new_swap_chain = nullptr;
		if (FAILED(s->s_->QueryInterface(&new_swap_chain)))
			return E_NOINTERFACE;
		s->s_->Release();
		s->s_ = new_swap_chain;
		s->version_ = V;
	}
	return S_OK;
}
void DXGISwapChain::updateHook() {
	h_->version_ = version_;
	if (h_->s_)
		h_->s_->Release();
	h_->s_ = s_;
	h_->s_->AddRef();
}

DXGISwapChain::DXGISwapChain(D3D11Device * device, IDXGISwapChain * original, std::shared_ptr<DXGISwapChainHook> hook) :
	s_(original), version_(0), device_(device), h_(hook) {
	updateHook();
}
DXGISwapChain::DXGISwapChain(D3D11Device * device, IDXGISwapChain1 * original, std::shared_ptr<DXGISwapChainHook> hook) :
	s_(original), version_(1), device_(device), h_(hook) {
	updateHook();
}

HRESULT STDMETHODCALLTYPE DXGISwapChain::QueryInterface(REFIID riid, void **ppvObj) {
	if (ppvObj == nullptr) {
		return E_POINTER;
	}
	else if (riid == __uuidof(this) || riid == __uuidof(IUnknown) || riid == __uuidof(IDXGIObject) || riid == __uuidof(IDXGIDeviceSubObject) || riid == __uuidof(IDXGISwapChain) || riid == __uuidof(IDXGISwapChain1) || riid == __uuidof(IDXGISwapChain2) || riid == __uuidof(IDXGISwapChain3)) {
		HRESULT r = upgrade<IDXGISwapChain1, 1>(this, riid, ppvObj);
		if (FAILED(r)) return r;
		r = upgrade<IDXGISwapChain2, 2>(this, riid, ppvObj);
		if (FAILED(r)) return r;
		r = upgrade<IDXGISwapChain3, 3>(this, riid, ppvObj);
		if (FAILED(r)) return r;
		updateHook();
		AddRef();
		*ppvObj = this;
		return S_OK;
	}
	return s_->QueryInterface(riid, ppvObj);
}
ULONG STDMETHODCALLTYPE DXGISwapChain::AddRef() {
	ref_++;
	return s_->AddRef();
}
ULONG STDMETHODCALLTYPE DXGISwapChain::Release() {
	if (--ref_ == 0) {
		h_.reset();
		device_->Release();
	}
	ULONG ref = s_->Release();

	if (ref_ == 0 && ref != 0) {
		LOG(WARN) << "Reference count for 'IDXGISwapChain" << (version_ > 0 ? std::to_string(version_) : "") << "' object " << this << " is inconsistent: " << ref << ", but expected 0.";
		ref = 0;
	}

	if (ref == 0) {
		ASSERT(ref_ <= 0);
		delete this;
	}

	return ref;
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::SetPrivateData(REFGUID Name, UINT DataSize, const void *pData) {
	return s_->SetPrivateData(Name, DataSize, pData);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::SetPrivateDataInterface(REFGUID Name, const IUnknown *pUnknown) {
	return s_->SetPrivateDataInterface(Name, pUnknown);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetPrivateData(REFGUID Name, UINT *pDataSize, void *pData) {
	return s_->GetPrivateData(Name, pDataSize, pData);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetParent(REFIID riid, void **ppParent) {
	return s_->GetParent(riid, ppParent);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetDevice(REFIID riid, void **ppDevice) {
	if (ppDevice == nullptr)
		return DXGI_ERROR_INVALID_CALL;
	return device_->QueryInterface(riid, ppDevice);
}

/**** Autogenerated hook source ****/
HRESULT DXGISwapChainHook::Present(UINT SyncInterval, UINT Flags) {
	return s_->Present(SyncInterval, Flags);
}
HRESULT DXGISwapChainHook::GetBuffer(UINT Buffer, REFIID riid, void **ppSurface) {
	return s_->GetBuffer(Buffer, riid, ppSurface);
}
HRESULT DXGISwapChainHook::SetFullscreenState(BOOL Fullscreen, IDXGIOutput *pTarget) {
	return s_->SetFullscreenState(Fullscreen, pTarget);
}
HRESULT DXGISwapChainHook::GetFullscreenState(BOOL *pFullscreen, IDXGIOutput **ppTarget) {
	return s_->GetFullscreenState(pFullscreen, ppTarget);
}
HRESULT DXGISwapChainHook::GetDesc(DXGI_SWAP_CHAIN_DESC *pDesc) {
	return s_->GetDesc(pDesc);
}
HRESULT DXGISwapChainHook::ResizeBuffers(UINT BufferCount, UINT Width, UINT Height, DXGI_FORMAT NewFormat, UINT SwapChainFlags) {
	return s_->ResizeBuffers(BufferCount, Width, Height, NewFormat, SwapChainFlags);
}
HRESULT DXGISwapChainHook::ResizeTarget(const DXGI_MODE_DESC *pNewTargetParameters) {
	return s_->ResizeTarget(pNewTargetParameters);
}
HRESULT DXGISwapChainHook::GetContainingOutput(IDXGIOutput **ppOutput) {
	return s_->GetContainingOutput(ppOutput);
}
HRESULT DXGISwapChainHook::GetFrameStatistics(DXGI_FRAME_STATISTICS *pStats) {
	return s_->GetFrameStatistics(pStats);
}
HRESULT DXGISwapChainHook::GetLastPresentCount(UINT *pLastPresentCount) {
	return s_->GetLastPresentCount(pLastPresentCount);
}
HRESULT DXGISwapChainHook::GetDesc1(DXGI_SWAP_CHAIN_DESC1 *pDesc) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->GetDesc1(pDesc);
}
HRESULT DXGISwapChainHook::GetFullscreenDesc(DXGI_SWAP_CHAIN_FULLSCREEN_DESC *pDesc) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->GetFullscreenDesc(pDesc);
}
HRESULT DXGISwapChainHook::GetHwnd(HWND *pHwnd) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->GetHwnd(pHwnd);
}
HRESULT DXGISwapChainHook::GetCoreWindow(REFIID refiid, void **ppUnk) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->GetCoreWindow(refiid, ppUnk);
}
HRESULT DXGISwapChainHook::Present1(UINT SyncInterval, UINT PresentFlags, const DXGI_PRESENT_PARAMETERS *pPresentParameters) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->Present1(SyncInterval, PresentFlags, pPresentParameters);
}
BOOL DXGISwapChainHook::IsTemporaryMonoSupported() {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->IsTemporaryMonoSupported();
}
HRESULT DXGISwapChainHook::GetRestrictToOutput(IDXGIOutput **ppRestrictToOutput) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->GetRestrictToOutput(ppRestrictToOutput);
}
HRESULT DXGISwapChainHook::SetBackgroundColor(const DXGI_RGBA *pColor) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->SetBackgroundColor(pColor);
}
HRESULT DXGISwapChainHook::GetBackgroundColor(DXGI_RGBA *pColor) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->GetBackgroundColor(pColor);
}
HRESULT DXGISwapChainHook::SetRotation(DXGI_MODE_ROTATION Rotation) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->SetRotation(Rotation);
}
HRESULT DXGISwapChainHook::GetRotation(DXGI_MODE_ROTATION *pRotation) {
	ASSERT(version_ >= 1);
	return static_cast<IDXGISwapChain1 *>(s_)->GetRotation(pRotation);
}
HRESULT DXGISwapChainHook::SetSourceSize(UINT Width, UINT Height) {
	ASSERT(version_ >= 2);
	return static_cast<IDXGISwapChain2 *>(s_)->SetSourceSize(Width, Height);
}
HRESULT DXGISwapChainHook::GetSourceSize(UINT *pWidth, UINT *pHeight) {
	ASSERT(version_ >= 2);
	return static_cast<IDXGISwapChain2 *>(s_)->GetSourceSize(pWidth, pHeight);
}
HRESULT DXGISwapChainHook::SetMaximumFrameLatency(UINT MaxLatency) {
	ASSERT(version_ >= 2);
	return static_cast<IDXGISwapChain2 *>(s_)->SetMaximumFrameLatency(MaxLatency);
}
HRESULT DXGISwapChainHook::GetMaximumFrameLatency(UINT *pMaxLatency) {
	ASSERT(version_ >= 2);
	return static_cast<IDXGISwapChain2 *>(s_)->GetMaximumFrameLatency(pMaxLatency);
}
HANDLE DXGISwapChainHook::GetFrameLatencyWaitableObject() {
	ASSERT(version_ >= 2);
	return static_cast<IDXGISwapChain2 *>(s_)->GetFrameLatencyWaitableObject();
}
HRESULT DXGISwapChainHook::SetMatrixTransform(const DXGI_MATRIX_3X2_F *pMatrix) {
	ASSERT(version_ >= 2);
	return static_cast<IDXGISwapChain2 *>(s_)->SetMatrixTransform(pMatrix);
}
HRESULT DXGISwapChainHook::GetMatrixTransform(DXGI_MATRIX_3X2_F *pMatrix) {
	ASSERT(version_ >= 2);
	return static_cast<IDXGISwapChain2 *>(s_)->GetMatrixTransform(pMatrix);
}
UINT DXGISwapChainHook::GetCurrentBackBufferIndex() {
	ASSERT(version_ >= 3);
	return static_cast<IDXGISwapChain3 *>(s_)->GetCurrentBackBufferIndex();
}
HRESULT DXGISwapChainHook::CheckColorSpaceSupport(DXGI_COLOR_SPACE_TYPE ColorSpace, UINT *pColorSpaceSupport) {
	ASSERT(version_ >= 3);
	return static_cast<IDXGISwapChain3 *>(s_)->CheckColorSpaceSupport(ColorSpace, pColorSpaceSupport);
}
HRESULT DXGISwapChainHook::SetColorSpace1(DXGI_COLOR_SPACE_TYPE ColorSpace) {
	ASSERT(version_ >= 3);
	return static_cast<IDXGISwapChain3 *>(s_)->SetColorSpace1(ColorSpace);
}
HRESULT DXGISwapChainHook::ResizeBuffers1(UINT BufferCount, UINT Width, UINT Height, DXGI_FORMAT Format, UINT SwapChainFlags, const UINT *pCreationNodeMask, IUnknown *const *ppPresentQueue) {
	ASSERT(version_ >= 3);
	return static_cast<IDXGISwapChain3 *>(s_)->ResizeBuffers1(BufferCount, Width, Height, Format, SwapChainFlags, pCreationNodeMask, ppPresentQueue);
}
/**** End autogenerated hook source ****/

/**** Autogenerated source ****/
HRESULT STDMETHODCALLTYPE DXGISwapChain::Present(UINT SyncInterval, UINT Flags) {
	return h_->Present(SyncInterval, Flags);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetBuffer(UINT Buffer, REFIID riid, void **ppSurface) {
	return h_->GetBuffer(Buffer, riid, ppSurface);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::SetFullscreenState(BOOL Fullscreen, IDXGIOutput *pTarget) {
	return h_->SetFullscreenState(Fullscreen, pTarget);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetFullscreenState(BOOL *pFullscreen, IDXGIOutput **ppTarget) {
	return h_->GetFullscreenState(pFullscreen, ppTarget);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetDesc(DXGI_SWAP_CHAIN_DESC *pDesc) {
	return h_->GetDesc(pDesc);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::ResizeBuffers(UINT BufferCount, UINT Width, UINT Height, DXGI_FORMAT NewFormat, UINT SwapChainFlags) {
	return h_->ResizeBuffers(BufferCount, Width, Height, NewFormat, SwapChainFlags);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::ResizeTarget(const DXGI_MODE_DESC *pNewTargetParameters) {
	return h_->ResizeTarget(pNewTargetParameters);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetContainingOutput(IDXGIOutput **ppOutput) {
	return h_->GetContainingOutput(ppOutput);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetFrameStatistics(DXGI_FRAME_STATISTICS *pStats) {
	return h_->GetFrameStatistics(pStats);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetLastPresentCount(UINT *pLastPresentCount) {
	return h_->GetLastPresentCount(pLastPresentCount);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetDesc1(DXGI_SWAP_CHAIN_DESC1 *pDesc) {
	return h_->GetDesc1(pDesc);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetFullscreenDesc(DXGI_SWAP_CHAIN_FULLSCREEN_DESC *pDesc) {
	return h_->GetFullscreenDesc(pDesc);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetHwnd(HWND *pHwnd) {
	return h_->GetHwnd(pHwnd);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetCoreWindow(REFIID refiid, void **ppUnk) {
	return h_->GetCoreWindow(refiid, ppUnk);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::Present1(UINT SyncInterval, UINT PresentFlags, const DXGI_PRESENT_PARAMETERS *pPresentParameters) {
	return h_->Present1(SyncInterval, PresentFlags, pPresentParameters);
}
BOOL STDMETHODCALLTYPE DXGISwapChain::IsTemporaryMonoSupported() {
	return h_->IsTemporaryMonoSupported();
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetRestrictToOutput(IDXGIOutput **ppRestrictToOutput) {
	return h_->GetRestrictToOutput(ppRestrictToOutput);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::SetBackgroundColor(const DXGI_RGBA *pColor) {
	return h_->SetBackgroundColor(pColor);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetBackgroundColor(DXGI_RGBA *pColor) {
	return h_->GetBackgroundColor(pColor);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::SetRotation(DXGI_MODE_ROTATION Rotation) {
	return h_->SetRotation(Rotation);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetRotation(DXGI_MODE_ROTATION *pRotation) {
	return h_->GetRotation(pRotation);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::SetSourceSize(UINT Width, UINT Height) {
	return h_->SetSourceSize(Width, Height);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetSourceSize(UINT *pWidth, UINT *pHeight) {
	return h_->GetSourceSize(pWidth, pHeight);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::SetMaximumFrameLatency(UINT MaxLatency) {
	return h_->SetMaximumFrameLatency(MaxLatency);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetMaximumFrameLatency(UINT *pMaxLatency) {
	return h_->GetMaximumFrameLatency(pMaxLatency);
}
HANDLE STDMETHODCALLTYPE DXGISwapChain::GetFrameLatencyWaitableObject() {
	return h_->GetFrameLatencyWaitableObject();
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::SetMatrixTransform(const DXGI_MATRIX_3X2_F *pMatrix) {
	return h_->SetMatrixTransform(pMatrix);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::GetMatrixTransform(DXGI_MATRIX_3X2_F *pMatrix) {
	return h_->GetMatrixTransform(pMatrix);
}
UINT STDMETHODCALLTYPE DXGISwapChain::GetCurrentBackBufferIndex() {
	return h_->GetCurrentBackBufferIndex();
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::CheckColorSpaceSupport(DXGI_COLOR_SPACE_TYPE ColorSpace, UINT *pColorSpaceSupport) {
	return h_->CheckColorSpaceSupport(ColorSpace, pColorSpaceSupport);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::SetColorSpace1(DXGI_COLOR_SPACE_TYPE ColorSpace) {
	return h_->SetColorSpace1(ColorSpace);
}
HRESULT STDMETHODCALLTYPE DXGISwapChain::ResizeBuffers1(UINT BufferCount, UINT Width, UINT Height, DXGI_FORMAT Format, UINT SwapChainFlags, const UINT *pCreationNodeMask, IUnknown *const *ppPresentQueue) {
	return h_->ResizeBuffers1(BufferCount, Width, Height, Format, SwapChainFlags, pCreationNodeMask, ppPresentQueue);
}
/**** End autogenerated source ****/
