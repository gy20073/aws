#pragma once
#include <cstdint>
#include <string>
#include <vector>

struct InputType {
enum {
	CBUFFER=0,
	TBUFFER=1,
	SAMPLER=2,
	RWTEXTURE = 4,
	STRUCTURED = 5,
};
};

struct OperandType {
enum {
	TEMP,
	INPUT,
	OUTPUT,
	INDEXABLE_TEMP,
	IMMEDIATE32,
	IMMEDIATE64,
	SAMPLER,
	RESOURCE,
	CONSTANT_BUFFER,
	IMMEDIATE_CONSTANT_BUFFER,
	LABEL,
	INPUT_PRIMITIVEID,
	OUTPUT_DEPTH,
	NULL_,
	RASTERIZER,
	OUTPUT_COVERAGE_MASK,
	STREAM,
	FUNCTION_BODY,
	FUNCTION_TABLE,
	INTERFACE,
	FUNCTION_INPUT,
	FUNCTION_OUTPUT,
	OUTPUT_CONTROL_POINT_ID,
	INPUT_FORK_INSTANCE_ID,
	INPUT_JOIN_INSTANCE_ID,
	INPUT_CONTROL_POINT,
	OUTPUT_CONTROL_POINT,
	INPUT_PATCH_CONSTANT,
	INPUT_DOMAIN_POINT,
	THIS_POINTER,
	UNORDERED_ACCESS_VIEW,
	THREAD_GROUP_SHARED_MEMORY,
	INPUT_THREAD_ID,
	INPUT_THREAD_GROUP_ID,
	INPUT_THREAD_ID_IN_GROUP,
	INPUT_COVERAGE_MASK,
	INPUT_THREAD_ID_IN_GROUP_FLATTENED,
	INPUT_GS_INSTANCE_ID,
	OUTPUT_DEPTH_GREATER_EQUAL,
	OUTPUT_DEPTH_LESS_EQUAL,
	CYCLE_COUNTER,
};
};

struct OpCode {
enum {
	ADD,
	AND,
	BREAK,
	BREAKC,
	CALL,
	CALLC,
	CASE,
	CONTINUE,
	CONTINUEC,
	CUT,
	DEFAULT,
	DERIV_RTX,
	DERIV_RTY,
	DISCARD,
	DIV,
	DP2,
	DP3,
	DP4,
	ELSE,
	EMIT,
	EMITTHENCUT,
	ENDIF,
	ENDLOOP,
	ENDSWITCH,
	EQ,
	EXP,
	FRC,
	FTOI,
	FTOU,
	GE,
	IADD,
	IF,
	IEQ,
	IGE,
	ILT,
	IMAD,
	IMAX,
	IMIN,
	IMUL,
	INE,
	INEG,
	ISHL,
	ISHR,
	ITOF,
	LABEL,
	LD,
	LD_MS,
	LOG,
	LOOP,
	LT,
	MAD,
	MIN,
	MAX,
	CUSTOMDATA,
	MOV,
	MOVC,
	MUL,
	NE,
	NOP,
	NOT,
	OR,
	RESINFO,
	RET,
	RETC,
	ROUND_NE,
	ROUND_NI,
	ROUND_PI,
	ROUND_Z,
	RSQ,
	SAMPLE,
	SAMPLE_C,
	SAMPLE_C_LZ,
	SAMPLE_L,
	SAMPLE_D,
	SAMPLE_B,
	SQRT,
	SWITCH,
	SINCOS,
	UDIV,
	ULT,
	UGE,
	UMUL,
	UMAD,
	UMAX,
	UMIN,
	USHR,
	UTOF,
	XOR,
	DCL_RESOURCE,
	DCL_CONSTANT_BUFFER,
	DCL_SAMPLER,
	DCL_INDEX_RANGE,
	DCL_GS_OUTPUT_PRIMITIVE_TOPOLOGY,
	DCL_GS_INPUT_PRIMITIVE,
	DCL_MAX_OUTPUT_VERTEX_COUNT,
	DCL_INPUT,
	DCL_INPUT_SGV,
	DCL_INPUT_SIV,
	DCL_INPUT_PS,
	DCL_INPUT_PS_SGV,
	DCL_INPUT_PS_SIV,
	DCL_OUTPUT,
	DCL_OUTPUT_SGV,
	DCL_OUTPUT_SIV,
	DCL_TEMPS,
	DCL_INDEXABLE_TEMP,
	DCL_GLOBAL_FLAGS,
	D3D10_COUNT,
	LOD,
	GATHER4,
	SAMPLE_POS,
	SAMPLE_INFO,
	D3D10_1_COUNT,
	HS_DECLS,
	HS_CONTROL_POINT_PHASE,
	HS_FORK_PHASE,
	HS_JOIN_PHASE,
	EMIT_STREAM,
	CUT_STREAM,
	EMITTHENCUT_STREAM,
	INTERFACE_CALL,
	BUFINFO,
	DERIV_RTX_COARSE,
	DERIV_RTX_FINE,
	DERIV_RTY_COARSE,
	DERIV_RTY_FINE,
	GATHER4_C,
	GATHER4_PO,
	GATHER4_PO_C,
	RCP,
	F32TOF16,
	F16TOF32,
	UADDC,
	USUBB,
	COUNTBITS,
	FIRSTBIT_HI,
	FIRSTBIT_LO,
	FIRSTBIT_SHI,
	UBFE,
	IBFE,
	BFI,
	BFREV,
	SWAPC,
	DCL_STREAM,
	DCL_FUNCTION_BODY,
	DCL_FUNCTION_TABLE,
	DCL_INTERFACE,
	DCL_INPUT_CONTROL_POINT_COUNT,
	DCL_OUTPUT_CONTROL_POINT_COUNT,
	DCL_TESS_DOMAIN,
	DCL_TESS_PARTITIONING,
	DCL_TESS_OUTPUT_PRIMITIVE,
	DCL_HS_MAX_TESSFACTOR,
	DCL_HS_FORK_PHASE_INSTANCE_COUNT,
	DCL_HS_JOIN_PHASE_INSTANCE_COUNT,
	DCL_THREAD_GROUP,
	DCL_UNORDERED_ACCESS_VIEW_TYPED,
	DCL_UNORDERED_ACCESS_VIEW_RAW,
	DCL_UNORDERED_ACCESS_VIEW_STRUCTURED,
	DCL_THREAD_GROUP_SHARED_MEMORY_RAW,
	DCL_THREAD_GROUP_SHARED_MEMORY_STRUCTURED,
	DCL_RESOURCE_RAW,
	DCL_RESOURCE_STRUCTURED,
	LD_UAV_TYPED,
	STORE_UAV_TYPED,
	LD_RAW,
	STORE_RAW,
	LD_STRUCTURED,
	STORE_STRUCTURED,
	ATOMIC_AND,
	ATOMIC_OR,
	ATOMIC_XOR,
	ATOMIC_CMP_STORE,
	ATOMIC_IADD,
	ATOMIC_IMAX,
	ATOMIC_IMIN,
	ATOMIC_UMAX,
	ATOMIC_UMIN,
	IMM_ATOMIC_ALLOC,
	IMM_ATOMIC_CONSUME,
	IMM_ATOMIC_IADD,
	IMM_ATOMIC_AND,
	IMM_ATOMIC_OR,
	IMM_ATOMIC_XOR,
	IMM_ATOMIC_EXCH,
	IMM_ATOMIC_CMP_EXCH,
	IMM_ATOMIC_IMAX,
	IMM_ATOMIC_IMIN,
	IMM_ATOMIC_UMAX,
	IMM_ATOMIC_UMIN,
	SYNC,
	DADD,
	DMAX,
	DMIN,
	DMUL,
	DEQ,
	DGE,
	DLT,
	DNE,
	DMOV,
	DMOVC,
	DTOF,
	FTOD,
	EVAL_SNAPPED,
	EVAL_SAMPLE_INDEX,
	EVAL_CENTROID,
	DCL_GS_INSTANCE_COUNT
};
};
static const std::vector<std::string> OpCodeStr = { "ADD",
"AND",
"BREAK",
"BREAKC",
"CALL",
"CALLC",
"CASE",
"CONTINUE",
"CONTINUEC",
"CUT",
"DEFAULT",
"DERIV_RTX",
"DERIV_RTY",
"DISCARD",
"DIV",
"DP2",
"DP3",
"DP4",
"ELSE",
"EMIT",
"EMITTHENCUT",
"ENDIF",
"ENDLOOP",
"ENDSWITCH",
"EQ",
"EXP",
"FRC",
"FTOI",
"FTOU",
"GE",
"IADD",
"IF",
"IEQ",
"IGE",
"ILT",
"IMAD",
"IMAX",
"IMIN",
"IMUL",
"INE",
"INEG",
"ISHL",
"ISHR",
"ITOF",
"LABEL",
"LD",
"LD_MS",
"LOG",
"LOOP",
"LT",
"MAD",
"MIN",
"MAX",
"CUSTOMDATA",
"MOV",
"MOVC",
"MUL",
"NE",
"NOP",
"NOT",
"OR",
"RESINFO",
"RET",
"RETC",
"ROUND_NE",
"ROUND_NI",
"ROUND_PI",
"ROUND_Z",
"RSQ",
"SAMPLE",
"SAMPLE_C",
"SAMPLE_C_LZ",
"SAMPLE_L",
"SAMPLE_D",
"SAMPLE_B",
"SQRT",
"SWITCH",
"SINCOS",
"UDIV",
"ULT",
"UGE",
"UMUL",
"UMAD",
"UMAX",
"UMIN",
"USHR",
"UTOF",
"XOR",
"DCL_RESOURCE",
"DCL_CONSTANT_BUFFER",
"DCL_SAMPLER",
"DCL_INDEX_RANGE",
"DCL_GS_OUTPUT_PRIMITIVE_TOPOLOGY",
"DCL_GS_INPUT_PRIMITIVE",
"DCL_MAX_OUTPUT_VERTEX_COUNT",
"DCL_INPUT",
"DCL_INPUT_SGV",
"DCL_INPUT_SIV",
"DCL_INPUT_PS",
"DCL_INPUT_PS_SGV",
"DCL_INPUT_PS_SIV",
"DCL_OUTPUT",
"DCL_OUTPUT_SGV",
"DCL_OUTPUT_SIV",
"DCL_TEMPS",
"DCL_INDEXABLE_TEMP",
"DCL_GLOBAL_FLAGS",
"D3D10_COUNT",
"LOD",
"GATHER4",
"SAMPLE_POS",
"SAMPLE_INFO",
"D3D10_1_COUNT",
"HS_DECLS",
"HS_CONTROL_POINT_PHASE",
"HS_FORK_PHASE",
"HS_JOIN_PHASE",
"EMIT_STREAM",
"CUT_STREAM",
"EMITTHENCUT_STREAM",
"INTERFACE_CALL",
"BUFINFO",
"DERIV_RTX_COARSE",
"DERIV_RTX_FINE",
"DERIV_RTY_COARSE",
"DERIV_RTY_FINE",
"GATHER4_C",
"GATHER4_PO",
"GATHER4_PO_C",
"RCP",
"F32TOF16",
"F16TOF32",
"UADDC",
"USUBB",
"COUNTBITS",
"FIRSTBIT_HI",
"FIRSTBIT_LO",
"FIRSTBIT_SHI",
"UBFE",
"IBFE",
"BFI",
"BFREV",
"SWAPC",
"DCL_STREAM",
"DCL_FUNCTION_BODY",
"DCL_FUNCTION_TABLE",
"DCL_INTERFACE",
"DCL_INPUT_CONTROL_POINT_COUNT",
"DCL_OUTPUT_CONTROL_POINT_COUNT",
"DCL_TESS_DOMAIN",
"DCL_TESS_PARTITIONING",
"DCL_TESS_OUTPUT_PRIMITIVE",
"DCL_HS_MAX_TESSFACTOR",
"DCL_HS_FORK_PHASE_INSTANCE_COUNT",
"DCL_HS_JOIN_PHASE_INSTANCE_COUNT",
"DCL_THREAD_GROUP",
"DCL_UNORDERED_ACCESS_VIEW_TYPED",
"DCL_UNORDERED_ACCESS_VIEW_RAW",
"DCL_UNORDERED_ACCESS_VIEW_STRUCTURED",
"DCL_THREAD_GROUP_SHARED_MEMORY_RAW",
"DCL_THREAD_GROUP_SHARED_MEMORY_STRUCTURED",
"DCL_RESOURCE_RAW",
"DCL_RESOURCE_STRUCTURED",
"LD_UAV_TYPED",
"STORE_UAV_TYPED",
"LD_RAW",
"STORE_RAW",
"LD_STRUCTURED",
"STORE_STRUCTURED",
"ATOMIC_AND",
"ATOMIC_OR",
"ATOMIC_XOR",
"ATOMIC_CMP_STORE",
"ATOMIC_IADD",
"ATOMIC_IMAX",
"ATOMIC_IMIN",
"ATOMIC_UMAX",
"ATOMIC_UMIN",
"IMM_ATOMIC_ALLOC",
"IMM_ATOMIC_CONSUME",
"IMM_ATOMIC_IADD",
"IMM_ATOMIC_AND",
"IMM_ATOMIC_OR",
"IMM_ATOMIC_XOR",
"IMM_ATOMIC_EXCH",
"IMM_ATOMIC_CMP_EXCH",
"IMM_ATOMIC_IMAX",
"IMM_ATOMIC_IMIN",
"IMM_ATOMIC_UMAX",
"IMM_ATOMIC_UMIN",
"SYNC",
"DADD",
"DMAX",
"DMIN",
"DMUL",
"DEQ",
"DGE",
"DLT",
"DNE",
"DMOV",
"DMOVC",
"DTOF",
"FTOD",
"EVAL_SNAPPED",
"EVAL_SAMPLE_INDEX",
"EVAL_CENTROID",
"DCL_GS_INSTANCE_COUNT"};

static bool isDCL(uint32_t opcode) {
	return opcode < OpCodeStr.size() && OpCodeStr[opcode].substr(0,3) == "DCL";
}
