from __future__ import print_function
import re
import argparse
from os import path

parser = argparse.ArgumentParser()
parser.add_argument('file')
parser.add_argument('-r', '--hook-region', default=None)
args = parser.parse_args()

src = open(args.file, 'r').read()

# Find all classes of interest
struct_parse = re.compile('struct (\w*) : (ID\w*)')

function_parse = re.compile('virtual (\w+)( \w+)? (\w+)\((.*)\)');
iparse = re.compile('(\w*) *: *public([^{]*?)\{([^{}]*?)\}', re.MULTILINE | re.DOTALL)
fparse = re.compile('virtual +(__[\w()]+ )?(\w+) +(\w* )? *(\w+) *\((.*?)\) *= *0', re.MULTILINE | re.DOTALL)
aparse = re.compile('(const )? ?(\w+)([*& ]*)(\w*)?\s*(\[.*\])?$')

m = struct_parse.findall(src)

assert len(m) == 1, "Either no or too many classes found!"
name, iname = m[0]
var_name = name.replace('DXGI','').replace('D3D11', '')[0].lower()+'_'
while iname[-1].isnumeric():
	iname = iname[:-1]

if args.hook_region  is None:
	args.hook_region = iname + '\w*'

region_parse = re.compile('#pragma region ('+args.hook_region+')\n(.*?)#pragma endregion', re.MULTILINE | re.DOTALL)

r = region_parse.findall(src)

SRC = ""
HOOK_SRC = ""
HOOK_HDR = ""
for n,s in r:
	for ret_type, call_type, fname, args in function_parse.findall(s):
		t_args = ''
		if args.strip():
			t_args = ', '.join([a.replace('*','').replace('&','').split()[-1] for a in args.split(',')])
		
		SRC += '%s %s %s::%s(%s){\n'%(ret_type.strip(), call_type.strip(), name, fname, args)
		SRC += '\treturn h_->%s(%s);\n'%(fname, t_args)
		SRC += '}\n'
		
		HOOK_HDR += '\tvirtual %s %s(%s);\n'%(ret_type.strip(), fname, args)
		
		HOOK_SRC += '%s %sHook::%s(%s){\n'%(ret_type.strip(), name, fname, args)
		if n == iname:
			HOOK_SRC += '\treturn %s->%s(%s);\n'%(var_name, fname, t_args)
		else:
			HOOK_SRC += '\tASSERT(version_ >= %s);\n'%n[-1:]
			HOOK_SRC += '\treturn static_cast<%s *>(%s)->%s(%s);\n'%(n, var_name, fname, t_args)
		HOOK_SRC += '}\n'

print( '/**** Autogenerated source ****/' )
print( SRC[:-1] )
print( '/**** End autogenerated source ****/' )

print( '\t/**** Autogenerated hook header ****/' )
print( HOOK_HDR[:-1] )
print( '\t/**** End autogenerated hook header ****/' )

print( '/**** Autogenerated hook source ****/' )
print( HOOK_SRC[:-1] )
print( '/**** End autogenerated hook source ****/' )
		
	
# if args.H is not None:
	# if args.H == '': args.H = args.file
	# print( '#pragma once' )
	# print( '#include <%s>'%path.basename(args.H) )
	# print()

# def parse_args(a, id=0):
	# r = aparse.search(a.strip())
	# g = list(r.groups())
	# name = g[-2]
	# if name is None or len(name) == 0 and g[1] != 'void':
		# name = 'a%d'%id
		# a = a.strip()+' '+name
	# return (name, a.strip())

# body = {'IUnknown':{f[-2]: f for f in fparse.findall("""virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, void **ppvObject) = 0;
# virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
# virtual ULONG STDMETHODCALLTYPE Release(void) = 0;""")}}

# for c in iparse.findall(src):
	# n = c[0].strip()
	# inh = c[1].strip() 
	# funcs = {}
	# if len(inh) and inh in body:
		# funcs.update( body[inh] )
	# funcs.update( {f[-2]: f for f in fparse.findall(c[2])} )
	# body[n] = funcs
	# if cname.match(n):
		# if n[0] == 'I': wn = 'W'+n[1:]
		# else:  wn = 'W'+n
		# print( 'class %s : public %s {'%(wn, n) )
		# print( 'private:' )
		# print( '    %s(const %s &o):h_(o.h_){}'%(wn,wn) )
		# print( '    %s& operator=(const %s &o){}'%(wn,wn) )
		# print( 'public:' )
		# print( '    %s *h_;'%(n) )
		# print( '    %s(%s *h):h_(h){h_->AddRef();}'%(wn,n) )
		# print( '    virtual ~%s(){ h_->Release(); }'%(wn) )
		# print( '' )
		# for f in funcs.values():
			# a = [parse_args(i,k) for k,i in enumerate(f[-1].split(','))]
			# # Get the function arguments as used in declaration
			# f_a = ', '.join([i[1] for i in a])
			# # Get the name of arguments to pass on
			# p_a = ', '.join([i[0] for i in a if i[0] is not None])
			
			# print( '    virtual %s %s %s%s(%s) {'%(f[:-1]+(f_a,)) )
			# print( '        return h_->%s(%s);'%(f[-2], p_a) )
			# print( '    }' )
		# print( '};' )
		# print()
		# print()
